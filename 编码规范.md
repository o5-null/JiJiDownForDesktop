# JiJiDownForDesktop 编码规范指南

## 1. 项目结构规范

**目录结构**
```
JiJiDownForDesktop/
├── main.py              # 主程序入口，UI界面
├── core_manager.py      # 核心管理模块
├── config_manager.py    # 配置管理模块
├── system_info.py       # 系统信息工具类
├── utils.py            # 工具函数
├── requirements.txt    # 依赖包列表
├── config/            # 配置文件目录
├── resources/         # 资源文件目录
├── Download/          # 下载目录
├── TEMP/             # 临时文件目录
└── logs/             # 日志目录
```

## 2. 导入语句规范

**导入顺序**
```python
# 标准库导入
import json
import os
import sys
import asyncio
from pathlib import Path
from typing import Dict, Any, Optional

# 第三方库导入
from nicegui import ui, app
import requests
import yaml
from loguru import logger

# 本地模块导入
from core_manager import core_manager
from config_manager import config_manager
from system_info import system_info
from utils import create_file_browser_button
```

**导入规则**
- 使用绝对导入而非相对导入
- 每个导入语句单独一行
- 按标准库 → 第三方库 → 本地模块的顺序组织
- 使用 `from module import function` 避免命名冲突

## 3. 命名规范

**变量和函数命名**
```python
# 使用蛇形命名法（snake_case）
config_manager = ConfigManager()
core_filename = system_info.get_core_filename()

# 异步函数使用 async 前缀
async def download_core():
    pass

# 私有方法使用下划线前缀
def _get_default_config():
    pass
```

**类命名**
```python
# 使用驼峰命名法（CamelCase）
class ConfigManager:
    pass

class SystemInfo:
    pass
```

**常量命名**
```python
# 使用全大写蛇形命名法
CONFIG_SCHEMA = {
    'download_dir': {
        'path': 'download-task.download-dir',
        'default': lambda: str(Path('./Download').resolve()),
        'description': '下载目录'
    }
}
```

## 4. 代码风格规范

**缩进和换行**
```python
# 使用4个空格缩进
def get_config(self, config_key: str, use_cache: bool = True) -> Any:
    if use_cache and config_key in self._config_cache:
        return self._config_cache[config_key]
    
    if config_key not in self.CONFIG_SCHEMA:
        logger.warning(f"未知的配置项: {config_key}")
        return None
```

**函数定义**
```python
def get_config(self, config_key: str, use_cache: bool = True) -> Any:
    """
    统一配置访问方法 - 替代所有单独的get_xxx方法
    
    Args:
        config_key: 配置项键名，对应CONFIG_SCHEMA中的键
        use_cache: 是否使用缓存
        
    Returns:
        配置值
    """
    # 函数实现...
```

**类型注解**
```python
from typing import Dict, Any, Optional, Callable

def calculate_file_hash(self, file_path: str) -> Optional[str]:
    """计算文件的SHA256哈希值"""
    try:
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception as e:
        logger.error(f"计算文件hash失败: {str(e)}")
        return None
```

## 5. 注释规范

**文档字符串**
```python
class ConfigManager:
    """配置文件管理器"""
    
    def get_config(self, config_key: str, use_cache: bool = True) -> Any:
        """
        统一配置访问方法 - 替代所有单独的get_xxx方法
        
        Args:
            config_key: 配置项键名，对应CONFIG_SCHEMA中的键
            use_cache: 是否使用缓存
            
        Returns:
            配置值
        """
        pass
```

**行内注释**
```python
# 确保文件名安全 - 移除路径分隔符
safe_filename = Path(filename).name
file_path = save_dir / safe_filename

# 创建保存目录 - 使用Pathlib进行路径处理
save_dir = Path(save_path).resolve()
save_dir.mkdir(parents=True, exist_ok=True)
```

## 6. 错误处理规范

**异常处理**
```python
try:
    response = requests.get(url, stream=True, timeout=30)
    response.raise_for_status()
except requests.exceptions.RequestException as e:
    logger.error(f"网络请求失败: {str(e)}")
    return {'success': False, 'error': str(e)}
except Exception as e:
    logger.error(f"下载过程中发生未知错误: {str(e)}")
    return {'success': False, 'error': str(e)}
```

**日志记录**
```python
from loguru import logger

# 配置日志
logger.remove()  # 移除默认的日志处理器
logger.add(sys.stderr, colorize=True, level="INFO")
logger.add("logs/JFD_{time:YYYY-MM-DD}.log", 
           rotation="1 day", 
           retention="7 days", 
           format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} - {message}", 
           level="DEBUG")

# 使用不同级别的日志
logger.debug("调试信息")
logger.info("普通信息")
logger.warning("警告信息")
logger.error("错误信息")
logger.success("成功信息")
```

## 7. 异步编程规范

**异步函数定义**
```python
async def download_file(self, url: str, filename: str, save_path: str = "./resources", 
                      progress_callback: Optional[Callable] = None) -> dict:
    """异步下载文件"""
    # 异步实现...
```

**UI事件处理**
```python
async def start_core():
    with ui.dialog() as dialog, ui.card():
        # UI组件创建...
        
        async def run_core(log_display, dialog):
            log_display.push('正在启动核心...')
            try:
                success = core_manager.start_core(str(config_file_path))
                if success:
                    core_manager.add_log_callback(dialog.log_callback_ref)
                    log_display.push('核心启动成功！')
            except Exception as e:
                log_display.push(f'启动核心失败: {str(e)}')
```

## 8. 配置管理规范

**配置模式定义**
```python
CONFIG_SCHEMA = {
    'download_dir': {
        'path': 'download-task.download-dir',
        'default': lambda: str(Path('./Download').resolve()),
        'description': '下载目录',
        'validator': lambda x: isinstance(x, str),
        'post_processor': lambda path: ensure_dir(path)
    }
}
```

**路径处理**
```python
from pathlib import Path

def ensure_dir(path: str) -> str:
    """确保目录存在，如果不存在则创建"""
    path_obj = Path(path)
    path_obj.mkdir(parents=True, exist_ok=True)
    return str(path_obj)
```

## 9. UI组件规范

**NiceGUI组件使用**
```python
# 使用ui.log()组件替代textarea显示日志
log_display = ui.log().style('width: 600px; height: 400px; font-family: monospace; font-size: 12px; overflow-y: auto')

# 按钮事件处理
ui.button('开始运行', on_click=lambda: run_core(log_display, dialog))

# 对话框创建
with ui.dialog() as dialog, ui.card():
    ui.label('核心运行日志').style('font-size: 18px; font-weight: bold; margin-bottom: 10px')
```

## 10. 最佳实践总结

1. **模块化设计**：每个模块职责单一，便于维护和测试
2. **类型安全**：广泛使用类型注解，提高代码可读性和可靠性
3. **错误处理**：完善的异常处理和日志记录机制
4. **异步编程**：合理使用异步操作，避免UI阻塞
5. **路径安全**：使用pathlib处理文件路径，避免路径注入攻击
6. **配置驱动**：统一的配置管理机制，便于扩展和维护
7. **UI最佳实践**：遵循NiceGUI组件使用规范，确保良好的用户体验

## 11. 文件路径处理规范

**使用Pathlib处理路径**
```python
from pathlib import Path

# 创建目录
config_dir = Path('./config')
config_dir.mkdir(parents=True, exist_ok=True)

# 路径拼接
config_file = config_dir / 'config.yaml'

# 路径解析
if config_file.exists():
    absolute_path = config_file.resolve()
    parent_dir = config_file.parent
```

**避免字符串拼接**
```python
# 不推荐
config_path = './config/' + 'config.yaml'

# 推荐
config_path = Path('./config') / 'config.yaml'
```

这份编码规范指南基于当前项目的实际代码风格，可以作为大模型生成代码时的参考标准，确保生成的代码与现有代码库风格一致且符合最佳实践。